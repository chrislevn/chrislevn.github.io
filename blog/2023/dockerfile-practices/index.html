<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Good practices on writing Dockerfile | Christopher Loc Le</title> <meta name="author" content="Christopher Loc Le"> <meta name="description" content="A software engineer with a passion for connecting all things infrastructure and data. "> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?19f3075a2d19613090fe9e16b564e1fe" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/prof_pic.jpg?d19ea9a3c704eb5ced8d00c2a64bb308"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://christopherle.com//blog/2023/dockerfile-practices/"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?e74e74bf055e5729d44a7d031a5ca6a5" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Christopher </span>Loc Le</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects</a> </li> <li class="nav-item"> <a class="nav-link" href="/assets/pdf/christopher_resume_swe.pdf" target="_blank" rel="noopener noreferrer">resume</a> </li> <li class="nav-item"> <a class="nav-link" href="https://substack.com/@christopherle?utm_source=edit-profile-page" target="_blank" rel="noopener noreferrer">archive</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Good practices on writing Dockerfile</h1> <p class="post-meta">November 12, 2023</p> <p class="post-tags"> <a href="/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a>   ·   <a href="/blog/tag/docker"> <i class="fas fa-hashtag fa-sm"></i> docker</a>     ·   <a href="/blog/category/devops"> <i class="fas fa-tag fa-sm"></i> devops</a>   </p> </header> <article class="post-content"> <div id="markdown-content"> <p>Website: <a href="https://christopherle.com/blog/2023/dockerfile-practices/#s2-dockerfiles-practices">https://christopherle.com/blog/2023/dockerfile-practices/#s2-dockerfiles-practices</a> <br> Github: <a href="https://github.com/chrislevn/dockerfile-practices" rel="external nofollow noopener" target="_blank">https://github.com/chrislevn/dockerfile-practices</a> <br> Simple demos running Docker with Python: <a href="https://github.com/chrislevn/dockerfile-practices/tree/main/demo" rel="external nofollow noopener" target="_blank">https://github.com/chrislevn/dockerfile-practices/tree/main/demo</a></p> <details> <summary>Table of Contents</summary> <ul> <li><a href="#s1-background">1 Background</a></li> <li> <a href="#s2-dockerfiles-practices">2 Dockerfile’s practices</a> <ul> <li><a href="#s2.1-use-minimal-base-images">2.1 Use minimal base images</a></li> <li><a href="#s2.2-use-explicit-tags-for-the-base-image">2.2 Use explicit tags for the base image.</a></li> <li><a href="#s2.3-leverage-layer-caching">2.3 Leverage layer caching</a></li> <li><a href="#2.4-consolidate-related-operations">2.4 Consolidate related operations</a></li> <li><a href="#s2.5-remove-unnecessary-artifacts">2.5 Remove unnecessary artifacts</a></li> <li><a href="#s2.6-use-specific-copy-instructions">2.6 Use specific COPY instructions</a></li> <li><a href="#s2.7-document-your-dockerfile">2.7 Document your Dockerfile</a></li> <li><a href="#s2.8-use-dockerignore-file">2.8 Use .dockerignore file</a></li> <li><a href="#s2.9-test-your-image">2.9 Test your image</a></li> <li><a href="#s2.10-add-or-copy">2.10 ADD or COPY</a></li> </ul> </li> <li> <a href="#s3-security-practices">3 Security practices:</a> <ul> <li> <a href="#s3.1-use-environment-variables-for-configuration">3.1 Use environment variables for configuration</a> <ul> <li><a href="#s3.1.1-setting-dynamic-environment-values-arg-vs-env">3.1.1 Setting Dynamic Environment Values (ARG vs ENV)</a></li> </ul> </li> <li><a href="#s3.3-set-the-correct-container-user">3.3 Set the correct container user</a></li> <li><a href="#s3.4-create-a-non-root-user-in-the-dockerfile">3.4 Create a non-root user in the Dockerfile</a></li> <li><a href="#s3.5-avoid-running-containers-with-root-privileges">3.5 Avoid running containers with root privileges</a></li> </ul> </li> <li> <a href="#s4-other-references">4 Other references:</a> <ul> <li><a href="#s4.1-expose">4.1 EXPOSE</a></li> <li><a href="#s4.2-entrypoint-vs-cmd-vs-run">4.2 ENTRYPOINT vs CMD vs RUN</a></li> <li> <a href="#s4.3-docker-image-vs-docker-containers">4.3 Docker Image vs Docker Containers:</a> <ul> <li><a href="#s4.3.1-docker-image">4.3.1 Docker Image:</a></li> <li><a href="#s4.3.2-docker-container">4.3.2 Docker Container:</a></li> <li><a href="#s4.3.3-docker-image-vs-containers">4.3.3 Docker Image vs Containers</a></li> </ul> </li> <li><a href="#s4.4-workdir">4.4 WORKDIR</a></li> <li><a href="#s4.5-volume">4.5 VOLUME</a></li> <li><a href="#s4.6-user">4.6 USER</a></li> <li><a href="#s4.7-onbuild">4.7 ONBUILD</a></li> </ul> </li> <li><a href="#s5-good-demo">5 Good demo</a></li> <li> <a href="#s6-basic-steps-to-running-docker-file-with-docker-cli">6 Basic steps to running Docker file with docker cli:</a> <ul> <li> <a href="#s6.1-run-docker-with-docker-compose">6.1 Running Docker with Docker compose</a> <ul> <li><a href="#s6.1.1-docker-compose">6.1.1 Docker compose</a></li> <li><a href='#s6.1.2-docker-compose-vs-docker-run"'>6.1.2 Docker compose vs Docker run</a></li> <li><a href="#s6.1.3-docker-compose-usage">6.1.3 Docker compose usage</a></li> </ul> </li> <li> <a href="#s6.2-run-docker-with-kubernetes">6.2 Running Docker image with Kubernetes</a> <ul> <li><a href="#s6.2.1-what-is-kubernetes">6.2.1 What is Kubernetes</a></li> <li><a href="#s6.2.2-run-public-docker-image-with-kubernetes">6.2.2 Running public Docker image with Kubernetes</a></li> <li><a href="#s6.2.3-run-private-docker-image-with-kubernetes">6.2.3 Running private Docker image with Kubernetes</a></li> <li><a href="#s6.2.4-run-docker-image-with-minikube">6.2.4 Running Docker image with Minikube</a></li> </ul> </li> <li> <a href="#s6.3-add-load-balancer-with-nginx">6.3 Add load balancer with Nginx</a> <ul> <li><a href="#s6.3.1-what-is-load-balancer">6.3.1 What is load balancer</a></li> <li><a href="#s6.3.2-ngnix">6.3.2 Ngnix</a></li> <li><a href="#s6.3.3-add-load-balancer-to-docker-compose">6.3.3 Add load balancer to Docker compose</a></li> </ul> </li> </ul> </li> <li> <a href="#s7-contributing">7 Contributing</a> <ul> <li><a href="#s7.1-contributing-guide">7.1 Contributing guide</a></li> <li><a href="#s7.2-acknowledgement">7.2 Acknowledgement</a></li> </ul> </li> <li><a href="#s8-references">8 References:</a></li> </ul> </details> <hr> <h2 id="1-background">1. Background</h2> <p><a id="s1-background"></a></p> <p>Docker is an open-source platform that enables you to automate the deployment, scaling, and management of applications using containerization. It provides a way to package applications and their dependencies into a standardized unit called a container.</p> <p>This guide is a list of practices I have collected, while learning Docker, for building your own Dockerfile. If you have new tips, feel free to contribute via <a href="https://github.com/chrislevn/dockerfile-practices/blob/main/CONTRIBUTING.md" rel="external nofollow noopener" target="_blank">Contributing guide</a>. Hope this helps!</p> <h2 id="2-dockerfiles-practices">2. Dockerfile’s practices</h2> <p><a id="s2-dockerfiles-practices"></a></p> <h3 id="21-use-minimal-base-images">2.1 Use minimal base images</h3> <p><a id="s2.1-use-minimal-base-images"></a></p> <p>Start with a minimal base image that contains only the necessary dependencies for your application. Using a smaller image reduces the image size and improves startup time.</p> <p>No:</p> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> python:3.9</span>
</code></pre></div></div> <p>Yes:</p> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> python:3.9-slim</span>
</code></pre></div></div> <p>Base image types:</p> <ul> <li>stretch/buster/jessie: is the codename for Debian 10, which is a specific version of the Debian operating system. Debian-based images often have different releases named after characters from the Toy Story movies. For example, “Jessie” refers to Debian 8, “Stretch” refers to Debian 9, and “Buster” refers to Debian 10. These releases represent different versions of the Debian distribution and come with their own set of package versions and features.</li> <li>slim: is a term commonly used to refer to Debian-based base images that have been optimized for size. These images are built on Debian but are trimmed down to include only the essential packages required to run applications. They are a good compromise between size and functionality, providing a balance between a minimal footprint and the availability of a wide range of packages.</li> <li>alpine: Alpine Linux is a lightweight Linux distribution designed for security, simplicity, and resource efficiency. Alpine-based images are known for their small size and are highly popular in the Docker ecosystem. They use the musl libc library instead of the more common glibc found in most Linux distributions. Alpine images are often significantly smaller compared to their Debian counterparts but may have a slightly different package ecosystem and may require adjustments to some application configurations due to the differences in the underlying system libraries. However, some teams are moving away from alpine because these images can cause compatibility issues that are hard to debug. Specifically, if using python images, some wheels are built to be compatible with Debian and will need to be recompiled to work with an Apline-based image.</li> </ul> <p>References:</p> <ul> <li>https://medium.com/swlh/alpine-slim-stretch-buster-jessie-bullseye-bookworm-what-are-the-differences-in-docker-62171ed4531d</li> </ul> <h3 id="22-use-explicit-tags-for-the-base-image">2.2 Use explicit tags for the base image.</h3> <p><a id="s2.2-use-explicit-tags-for-the-base-image"></a></p> <p>Use explicit tags for the base image instead of generic ones like ‘latest’ to ensure the same base image is used consistently across different environments.</p> <p>No:</p> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> company/image_name:latest</span>
</code></pre></div></div> <p>Yes:</p> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> company/image_name:version</span>
</code></pre></div></div> <h3 id="23-leverage-layer-caching">2.3 Leverage layer caching</h3> <p><a id="s2.3-leverage-layer-caching"></a></p> <p>Docker builds images using a layered approach, and it caches each layer. Place the instructions that change less frequently towards the top of the Dockerfile. This allows Docker to reuse cached layers during subsequent builds, speeding up the build process.</p> <p>No:</p> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> ubuntu:20.04</span>

<span class="c"># Install system dependencies</span>
<span class="k">RUN </span>apt-get update <span class="o">&amp;&amp;</span> <span class="se">\
</span>    apt-get <span class="nb">install</span> <span class="nt">-y</span> curl

<span class="c"># Install application dependencies</span>
<span class="k">RUN </span>curl <span class="nt">-sL</span> https://deb.nodesource.com/setup_14.x | bash - <span class="o">&amp;&amp;</span> <span class="se">\
</span>    apt-get <span class="nb">install</span> <span class="nt">-y</span> nodejs

<span class="c"># Copy application files</span>
<span class="k">COPY</span><span class="s"> . /app</span>

<span class="c"># Build the application</span>
<span class="k">RUN </span><span class="nb">cd</span> /app <span class="o">&amp;&amp;</span> <span class="se">\
</span>    npm <span class="nb">install</span> <span class="o">&amp;&amp;</span> <span class="se">\
</span>    npm run build

</code></pre></div></div> <p>In this example, each <code class="language-plaintext highlighter-rouge">RUN</code> instruction creates a new layer, making it difficult to leverage layer caching effectively. Even if there are no changes to the application code, every step from installing system dependencies to building the application will be repeated during each build, resulting in slower build times.</p> <p>Yes:</p> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> ubuntu:20.04</span>

<span class="c"># Install system dependencies</span>
<span class="k">RUN </span>apt-get update <span class="o">&amp;&amp;</span> <span class="se">\
</span>    apt-get <span class="nb">install</span> <span class="nt">-y</span> curl

<span class="c"># Install application dependencies</span>
<span class="k">RUN </span>curl <span class="nt">-sL</span> https://deb.nodesource.com/setup_14.x | bash - <span class="o">&amp;&amp;</span> <span class="se">\
</span>    apt-get <span class="nb">install</span> <span class="nt">-y</span> nodejs

<span class="c"># Set working directory</span>
<span class="k">WORKDIR</span><span class="s"> /app</span>

<span class="c"># Copy only package.json and package-lock.json</span>
<span class="k">COPY</span><span class="s"> package.json package-lock.json /app/</span>

<span class="c"># Install dependencies</span>
<span class="k">RUN </span>npm <span class="nb">install</span>

<span class="c"># Copy the rest of the application files</span>
<span class="k">COPY</span><span class="s"> . /app</span>

<span class="c"># Build the application</span>
<span class="k">RUN </span>npm run build
</code></pre></div></div> <p>In this improved example, we take advantage of layer caching by separating the steps that change less frequently from the steps that change more frequently. Only the necessary files (package.json and package-lock.json) are copied in a separate layer to install the dependencies. This allows Docker to reuse the cached layer for subsequent builds as long as the dependency files remain unchanged. The rest of the application files are copied in a separate step, reducing unnecessary cache invalidation.</p> <h3 id="24-consolidate-related-operations">2.4 Consolidate related operations</h3> <p><a id="2.4-consolidate-related-operations"></a></p> <p>Minimize the number of layers by combining related operations into a single instruction. For example, instead of installing multiple packages in separate <code class="language-plaintext highlighter-rouge">RUN</code> instructions, group them together using a single RUN instruction.</p> <p>No:</p> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> ubuntu:20.04</span>

<span class="c"># Install dependencies</span>
<span class="k">RUN </span>apt-get update <span class="o">&amp;&amp;</span> <span class="se">\
</span>    apt-get <span class="nb">install</span> <span class="nt">-y</span> curl

<span class="c"># Install Node.js</span>
<span class="k">RUN </span>curl <span class="nt">-sL</span> https://deb.nodesource.com/setup_14.x | bash - <span class="o">&amp;&amp;</span> <span class="se">\
</span>    apt-get <span class="nb">install</span> <span class="nt">-y</span> nodejs

<span class="c"># Install project dependencies</span>
<span class="k">RUN </span>npm <span class="nb">install </span>express
<span class="k">RUN </span>npm <span class="nb">install </span>lodash
<span class="k">RUN </span>npm <span class="nb">install </span>axios

</code></pre></div></div> <p>In this example, each package installation is done in a separate <code class="language-plaintext highlighter-rouge">RUN</code> instruction. This approach creates unnecessary layers and increases the number of cache invalidations. Even if one package changes, all subsequent package installations will be repeated during each build, leading to slower build times.</p> <p>Yes:</p> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> ubuntu:20.04</span>

<span class="c"># Install dependencies and Node.js</span>
<span class="k">RUN </span>apt-get update <span class="o">&amp;&amp;</span> <span class="se">\
</span>    apt-get <span class="nb">install</span> <span class="nt">-y</span> <span class="se">\
</span>        curl <span class="se">\
</span>        nodejs

<span class="c"># Install project dependencies</span>
<span class="k">RUN </span>npm <span class="nb">install </span>express lodash axios
</code></pre></div></div> <p>In this improved example, related package installations are consolidated into a single RUN instruction. This approach reduces the number of layers and improves layer caching. If no changes occur in the package.json file, Docker can reuse the previously cached layer for the npm install step, resulting in faster builds.</p> <h3 id="25-remove-unnecessary-artifacts">2.5 Remove unnecessary artifacts</h3> <p><a id="s2.5-remove-unnecessary-artifacts"></a></p> <p>Clean up any unnecessary artifacts created during the build process to reduce the size of the final image. For example, remove temporary files, unused dependencies, and package caches.</p> <p>No:</p> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> ubuntu:20.04</span>

<span class="c"># Install dependencies</span>
<span class="k">RUN </span>apt-get update <span class="o">&amp;&amp;</span> <span class="se">\
</span>    apt-get <span class="nb">install</span> <span class="nt">-y</span> curl

<span class="c"># Download application package</span>
<span class="k">RUN </span>curl <span class="nt">-O</span> https://example.com/app.tar.gz

<span class="c"># Extract application package</span>
<span class="k">RUN </span><span class="nb">tar</span> <span class="nt">-xzf</span> app.tar.gz

<span class="c"># Remove unnecessary artifacts</span>
<span class="k">RUN </span><span class="nb">rm </span>app.tar.gz
</code></pre></div></div> <p>In this example, the unnecessary artifacts, such as the downloaded app.tar.gz file, are removed in a separate RUN instruction. However, this approach doesn’t take advantage of Docker’s layer caching. Even if no changes are made to the downloaded package, Docker will not be able to reuse the cached layer and will repeat the download, extraction, and removal steps during each build.</p> <p>Yes:</p> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> ubuntu:20.04</span>

<span class="c"># Install dependencies</span>
<span class="k">RUN </span>apt-get update <span class="o">&amp;&amp;</span> <span class="se">\
</span>    apt-get <span class="nb">install</span> <span class="nt">-y</span> curl

<span class="c"># Download and extract application package, then remove unnecessary artifacts</span>
<span class="k">RUN </span>curl <span class="nt">-O</span> https://example.com/app.tar.gz <span class="se">\
</span>    <span class="o">&amp;&amp;</span> <span class="nb">tar</span> <span class="nt">-xzf</span> app.tar.gz <span class="se">\
</span>    <span class="o">&amp;&amp;</span> <span class="nb">rm </span>app.tar.gz
</code></pre></div></div> <p>In this improved example, the unnecessary artifacts are removed immediately after they are no longer needed, within the same <code class="language-plaintext highlighter-rouge">RUN</code> instruction. By doing so, Docker can leverage layer caching effectively. If the downloaded package remains unchanged, Docker can reuse the cached layer, avoiding redundant downloads and extractions.</p> <p>In Python, avoid using <code class="language-plaintext highlighter-rouge">pip freeze &gt; requirements.txt</code> to generate libaries as it will install all related packages which can cause bugs, conflicts, and big file size.</p> <p>Solutions:</p> <ul> <li>Use <code class="language-plaintext highlighter-rouge">pipreqs</code>: pipreqs starts by scanning all the python files (.py) in your project, then generates the requirements.txt file based on the import statements in each python file of the project.</li> </ul> <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">pip install pipreqs
</span></code></pre></div></div> <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">pipreqs /&lt;your_project_root_path&gt;</span>/
</code></pre></div></div> <p>Sometimes you might want to update the requirement file. In this case, you need to use the –forceoption to force the regeneration of the file.</p> <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">pipreqs --force /&lt;your_project_root_path&gt;</span>/
</code></pre></div></div> <ul> <li> <code class="language-plaintext highlighter-rouge">cat requirements.txt | xargs -n 1 pip install</code> <br> Note: -a parameter is not available under MacOS, so old cat is more portable. Reference: <a href="https://stackoverflow.com/questions/22250483/stop-pip-from-failing-on-single-package-when-installing-with-requirements-txt" rel="external nofollow noopener" target="_blank">https://stackoverflow.com/questions/22250483/stop-pip-from-failing-on-single-package-when-installing-with-requirements-txt</a> </li> </ul> <h3 id="26-use-specific-copy-instructions">2.6 Use specific COPY instructions</h3> <p><a id="s2.6-use-specific-copy-instructions"></a></p> <p>When copying files into the image, be specific about what you’re copying. Avoid using . (dot) as the source directory, as it can inadvertently include unwanted files. Instead, explicitly specify the files or directories you need.</p> <p>No:</p> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> ubuntu:20.04</span>

<span class="c"># Copy all files into the image</span>
<span class="k">COPY</span><span class="s"> . /app</span>
</code></pre></div></div> <p>In this example, the entire context directory, represented by . (dot), is copied into the image. This approach can inadvertently include unwanted files that may not be necessary for the application. It can bloat the image size and potentially expose sensitive files or credentials to the container.</p> <p>Yes:</p> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> ubuntu:20.04</span>

<span class="c"># Create app directory</span>
<span class="k">RUN </span><span class="nb">mkdir</span> /app

<span class="c"># Copy only necessary files</span>
<span class="k">COPY</span><span class="s"> app.py requirements.txt /app/</span>
</code></pre></div></div> <p>In this improved example, specific files (app.py and requirements.txt) are copied into a designated directory (/app). By explicitly specifying the required files, you ensure that only the necessary files are included in the image. This approach helps keep the image size minimal and avoids exposing any unwanted or sensitive files to the container.</p> <h3 id="27-document-your-dockerfile">2.7 Document your Dockerfile</h3> <p><a id="s2.7-document-your-dockerfile"></a></p> <p>Include comments in your Dockerfile to provide context and explanations for the various instructions. This helps other developers understand the purpose and functionality of the Dockerfile.</p> <p>No:</p> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> ubuntu:20.04</span>

<span class="c"># Install dependencies</span>
<span class="k">RUN </span>apt-get update <span class="o">&amp;&amp;</span> apt-get <span class="nb">install</span> <span class="nt">-y</span> python3

<span class="c"># Set working directory</span>
<span class="k">WORKDIR</span><span class="s"> /app</span>

<span class="c"># Copy application files</span>
<span class="k">COPY</span><span class="s"> . /app</span>

<span class="c"># Run the application</span>
<span class="k">CMD</span><span class="s"> ["python3", "app.py"]</span>
</code></pre></div></div> <p>In this example, there is no explicit documentation or comments to explain the purpose or functionality of each instruction in the Dockerfile. It can make it challenging for other developers or maintainers to understand the intended usage or any specific requirements.</p> <p>Yes:</p> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> ubuntu:20.04</span>

<span class="c"># Install Python</span>
<span class="k">RUN </span>apt-get update <span class="o">&amp;&amp;</span> apt-get <span class="nb">install</span> <span class="nt">-y</span> python3

<span class="c"># Set working directory</span>
<span class="k">WORKDIR</span><span class="s"> /app</span>

<span class="c"># Copy application files</span>
<span class="k">COPY</span><span class="s"> . /app</span>

<span class="c"># Set the entrypoint command to run the application</span>
<span class="k">CMD</span><span class="s"> ["python3", "app.py"]</span>

<span class="c"># </span>
port 8000 for accessing the application
<span class="k">EXPOSE</span><span class="s"> 8000</span>

<span class="c"># Document the purpose of the image and any additional details</span>
<span class="k">LABEL</span><span class="s"> maintainer="John Doe &lt;john@example.com&gt;"</span>
<span class="k">LABEL</span><span class="s"> description="Docker image for running the example application."</span>
<span class="k">LABEL</span><span class="s"> version="1.0"</span>
</code></pre></div></div> <p>In this improved example, the Dockerfile is better documented:</p> <ul> <li>Each instruction is accompanied by a comment or description that explains its purpose.</li> <li>The <code class="language-plaintext highlighter-rouge">LABEL</code> instructions are used to provide additional information about the image, such as the maintainer, description, and version.</li> <li>The <code class="language-plaintext highlighter-rouge">EXPOSE</code> instruction documents the port that should be exposed for accessing the application.</li> </ul> <h3 id="28-usedockerignore-file">2.8 Use .dockerignore file</h3> <p><a id="s2.8-use-dockerignore-file"></a></p> <p>The .dockerignore file allow you to exclude files the context like a .gitignore file allow you to exclude files from your git repository. It helps to make build faster and lighter by excluding from the context big files or repository that are not used in the build.</p> <p>No:</p> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> ubuntu:20.04</span>

<span class="c"># Copy all files into the image</span>
<span class="k">COPY</span><span class="s"> . /app</span>

<span class="c"># Build the application</span>
<span class="k">RUN </span>make build
</code></pre></div></div> <p>In this example, all files in the current directory are copied into the image, including unnecessary files such as development tools, build artifacts, or sensitive information. This can bloat the image size and potentially expose unwanted or sensitive files to the container.</p> <p>Yes:</p> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> ubuntu:20.04</span>

<span class="c"># Copy only necessary files into the image</span>
<span class="k">COPY</span><span class="s"> . /app</span>

<span class="c"># Build the application</span>
<span class="k">RUN </span>make build
</code></pre></div></div> <p>.dockerignore:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.git
node_modules
*.log
*.tmp
</code></pre></div></div> <p>In this improved example, a <code class="language-plaintext highlighter-rouge">.dockerignore</code> file is used to exclude unnecessary files and directories from being copied into the image. The .dockerignore file specifies patterns of files and directories that should be ignored during the build process. It helps reduce the image size, improve build performance, and avoid including unwanted files.</p> <p>The <code class="language-plaintext highlighter-rouge">.dockerignore</code> file in this example excludes the <code class="language-plaintext highlighter-rouge">.git</code> directory, the <code class="language-plaintext highlighter-rouge">node_modules</code> directory (common for Node.js projects), and files with extensions <code class="language-plaintext highlighter-rouge">.log</code> and <code class="language-plaintext highlighter-rouge">.tmp</code>. These files and directories are typically not needed in the final image and can be safely ignored.</p> <h3 id="29-test-your-image">2.9 Test your image</h3> <p><a id="s2.9-test-your-image"></a></p> <p>After building your Docker image, run it in a container to verify that everything works as expected. This ensures that your image is functional and can be used with confidence.</p> <p>No:</p> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> ubuntu:20.04</span>

<span class="c"># Copy application files</span>
<span class="k">COPY</span><span class="s"> . /app</span>

<span class="c"># Install dependencies</span>
<span class="k">RUN </span>apt-get update <span class="o">&amp;&amp;</span> apt-get <span class="nb">install</span> <span class="nt">-y</span> python3

<span class="c"># Run the application</span>
<span class="k">CMD</span><span class="s"> ["python3", "app.py"]</span>
</code></pre></div></div> <p>In this example, there is no explicit provision for testing the image. The Dockerfile only focuses on setting up the application, without any dedicated steps or considerations for running tests.</p> <p>Yes:</p> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> ubuntu:20.04</span>

<span class="c"># Copy application files</span>
<span class="k">COPY</span><span class="s"> . /app</span>

<span class="c"># Install dependencies</span>
<span class="k">RUN </span>apt-get update <span class="o">&amp;&amp;</span> apt-get <span class="nb">install</span> <span class="nt">-y</span> python3

<span class="c"># Run tests</span>
<span class="k">RUN </span>python3 <span class="nt">-m</span> unittest discover tests

<span class="c"># Run the application</span>
<span class="k">CMD</span><span class="s"> ["python3", "app.py"]</span>
</code></pre></div></div> <p>In this improved example, a dedicated step is added to run tests within the Dockerfile. The <code class="language-plaintext highlighter-rouge">RUN</code> instruction executes the necessary command to run tests using a testing framework (in this case, <code class="language-plaintext highlighter-rouge">unittest</code> is used as an example). By including this step, you ensure that tests are executed during the Docker image build process.</p> <p>It’s important to note that this example assumes the tests are included in a <code class="language-plaintext highlighter-rouge">tests</code> directory within the project structure. Adjust the command (<code class="language-plaintext highlighter-rouge">python3 -m unittest discover tests</code>) as per your project’s testing setup.</p> <h3 id="210-add-or-copy">2.10 ADD or COPY</h3> <p><a id="s2.10-add-or-copy"></a></p> <p>Although <code class="language-plaintext highlighter-rouge">ADD</code> and <code class="language-plaintext highlighter-rouge">COPY</code> are functionally similar, generally speaking, <code class="language-plaintext highlighter-rouge">COPY</code> is preferred. That’s because it’s more transparent than <code class="language-plaintext highlighter-rouge">ADD</code>. <code class="language-plaintext highlighter-rouge">COPY</code> only supports the basic copying of local files into the container, while <code class="language-plaintext highlighter-rouge">ADD</code> has some features (like local-only tar extraction and remote URL support) that are not immediately obvious. Consequently, the best use for <code class="language-plaintext highlighter-rouge">ADD</code> is local tar file auto-extraction into the image, as in <code class="language-plaintext highlighter-rouge">ADD rootfs.tar.xz /.</code></p> <p>If you have multiple Dockerfile steps that use different files from your context, <code class="language-plaintext highlighter-rouge">COPY</code> them individually, rather than all at once. This ensures that each step’s build cache is only invalidated, forcing the step to be re-run if the specifically required files change.</p> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">COPY</span><span class="s"> requirements.txt /tmp/</span>
<span class="k">RUN </span>pip <span class="nb">install</span> <span class="nt">--requirement</span> /tmp/requirements.txt
<span class="k">COPY</span><span class="s"> . /tmp/</span>
</code></pre></div></div> <p>Results in fewer cache invalidations for the <code class="language-plaintext highlighter-rouge">RUN</code> step, than if you put the <code class="language-plaintext highlighter-rouge">COPY . /tmp/</code> before it.</p> <p>Because image size matters, using <code class="language-plaintext highlighter-rouge">ADD</code> to fetch packages from remote URLs is strongly discouraged; you should use curl or wget instead. That way you can delete the files you no longer need after they’ve been extracted and you don’t have to add another layer in your image. For example, you should avoid doing things like:</p> <p>No:</p> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ADD</span><span class="s"> https://example.com/big.tar.xz /usr/src/things/</span>
<span class="k">RUN </span><span class="nb">tar</span> <span class="nt">-xJf</span> /usr/src/things/big.tar.xz <span class="nt">-C</span> /usr/src/things
<span class="k">RUN </span>make <span class="nt">-C</span> /usr/src/things all
</code></pre></div></div> <p>And instead, do something like:</p> <p>Yes:</p> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code> RUN mkdir -p /usr/src/things \
  &amp;&amp; curl -SL https://example.com/big.tar.xz \
  | tar -xJC /usr/src/things \
  &amp;&amp; make -C /usr/src/things all
</code></pre></div></div> <p>For other items, like files and directories, that don’t require the tar auto-extraction capability of <code class="language-plaintext highlighter-rouge">ADD</code>, you should always use <code class="language-plaintext highlighter-rouge">COPY</code>.</p> <p>For more information about ADD or COPY, see the following:</p> <ul> <li><a href="https://docs.docker.com/engine/reference/builder/#add" rel="external nofollow noopener" target="_blank">Dockerfile reference for the ADD instruction</a></li> <li><a href="https://docs.docker.com/engine/reference/builder/#copy" rel="external nofollow noopener" target="_blank">Dockerfile reference for the COPY instruction</a></li> </ul> <p>Reference: <a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#:~:text=COPY%20only%20supports%20the%20basic,rootfs.tar.xz%20%2F%20." rel="external nofollow noopener" target="_blank">https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#:~:text=COPY%20only%20supports%20the%20basic,rootfs.tar.xz%20%2F%20</a></p> <h2 id="3-security-practices">3. Security practices</h2> <p><a id="s3-security-practices"></a></p> <h3 id="31-use-environment-variables-for-configuration">3.1 Use environment variables for configuration</h3> <p><a id="s3.1-use-environment-variables-for-configuration"></a></p> <p>Instead of hardcoding configuration values inside the Dockerfile, use environment variables. This allows for greater flexibility and easier configuration management. You can set these variables when running the container.</p> <p>No:</p> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> ubuntu:20.04</span>

<span class="c"># Set configuration values directly</span>
<span class="k">ENV</span><span class="s"> DB_HOST=localhost</span>
<span class="k">ENV</span><span class="s"> DB_PORT=3306</span>
<span class="k">ENV</span><span class="s"> DB_USER=myuser</span>
<span class="k">ENV</span><span class="s"> DB_PASSWORD=mypassword</span>

<span class="c"># Run the application</span>
<span class="k">CMD</span><span class="s"> ["python3", "app.py"]</span>
</code></pre></div></div> <p>In this example, configuration values are directly set as environment variables using the ENV instruction in the Dockerfile. This approach has a few drawbacks:</p> <ul> <li>Configuration values are hardcoded in the Dockerfile, making it less flexible and harder to change without modifying the file itself.</li> <li>Sensitive information, such as passwords or API keys, is exposed in plain text in the Dockerfile, which is not secure.</li> </ul> <p>Yes:</p> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> ubuntu:20.04</span>

<span class="c"># Set default configuration values</span>
<span class="k">ENV</span><span class="s"> DB_HOST=localhost</span>
<span class="k">ENV</span><span class="s"> DB_PORT=3306</span>
<span class="k">ENV</span><span class="s"> DB_USER=defaultuser</span>
<span class="k">ENV</span><span class="s"> DB_PASSWORD=defaultpassword</span>

<span class="c"># Run the application</span>
<span class="k">CMD</span><span class="s"> ["python3", "app.py"]</span>
</code></pre></div></div> <p>In this improved example, default configuration values are set as environment variables, but they are kept generic and non-sensitive. This approach provides a template for configuration that can be customized when running the container.</p> <p>To securely provide sensitive configuration values, you can pass them as environment variables during runtime using the -e flag with the docker run command or by using a secrets management solution like Docker Secrets or environment-specific .env files.</p> <p>For example, when running the container, you can override the default values:</p> <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">docker run -e DB_HOST=mydbhost -e DB_PORT=5432 -e DB_USER=myuser -e DB_PASSWORD=mypassword myimage
</span></code></pre></div></div> <h4 id="311-setting-dynamic-environment-values-arg-vs-env">3.1.1 Setting Dynamic Environment Values (ARG vs ENV)</h4> <p><a id="s3.1.1-setting-dynamic-environment-values-arg-vs-env"></a></p> <p>Dockerfile doesn’t provide a dynamic tool to set an ENV value during the build process. However, there’s a solution to this problem. We have to use ARG. ARG values don’t work in the same way as ENV, as we can’t access them anymore once the image is built.</p> <p><img src="https://github.com/chrislevn/dockerfile-practices/assets/32094007/b45d08b5-6bb4-44db-bf0c-2a8b1d8e7ed6" alt="image"></p> <p>Let’s see how we can work around this issue:</p> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ARG</span><span class="s"> name</span>
<span class="k">ENV</span><span class="s"> env_name $name</span>
</code></pre></div></div> <p>We’ll introduce the name ARG variable. Then we’ll use it to assign a value to the env_name environment variable using ENV. When we want to set this argument, we’ll pass it with the –build-arg flag:</p> <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">docker build -t image_name --build-arg name=Christopher .
</span></code></pre></div></div> <p>Now we’ll run our container. We should see:</p> <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">Hello Christopher
</span></code></pre></div></div> <p>Reference: <a href="https://www.baeldung.com/ops/dockerfile-env-variable" rel="external nofollow noopener" target="_blank">https://www.baeldung.com/ops/dockerfile-env-variable</a></p> <h3 id="33-set-the-correct-container-user">3.3 Set the correct container user</h3> <p><a id="s3.3-set-the-correct-container-user"></a></p> <p>By default, Docker runs containers as the root user. To improve security, create a dedicated user for running your application within the container and switch to that user using the <code class="language-plaintext highlighter-rouge">USER</code> instruction.</p> <p>No:</p> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> ubuntu:20.04</span>

<span class="c"># Set working directory</span>
<span class="k">WORKDIR</span><span class="s"> /app</span>

<span class="c"># Copy application files</span>
<span class="k">COPY</span><span class="s"> . /app</span>

<span class="c"># Set container user as root</span>
<span class="k">USER</span><span class="s"> root</span>

<span class="c"># Run the application</span>
<span class="k">CMD</span><span class="s"> ["python3", "app.py"]</span>
</code></pre></div></div> <p>In this example, the container user is set to root using the USER instruction. Running the container as the root user can pose security risks, as any malicious code or vulnerability exploited within the container would have elevated privileges.</p> <p>Why it’s important:</p> <ul> <li> <p>Running processes within a container as a non-root user minimizes the potential damage that can be caused by security vulnerabilities</p> </li> <li> <p>Following the principle of least privilege, a non-root user only has access to the resources and permissions necessary to perform its intended tasks. This reduces the risk of accidental or intentional misuse of privileged operations within the container.</p> </li> <li> <p>Running containers with a non-root user adds an additional layer of isolation between the containerized application and the host system. This isolation helps protect the host system from unintended changes or malicious activities within the container.</p> </li> <li> <p>Many organizations and regulatory frameworks require the use of non-root users for security and compliance purposes. Adhering to these best practices can help meet these requirements and ensure that your containerized applications pass security audits.</p> </li> </ul> <p>Yes:</p> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> ubuntu:20.04</span>

<span class="c"># Set working directory</span>
<span class="k">WORKDIR</span><span class="s"> /app</span>

<span class="c"># Copy application files</span>
<span class="k">COPY</span><span class="s"> . /app</span>

<span class="c"># Create a non-root user</span>
<span class="k">RUN </span>groupadd <span class="nt">-r</span> myuser <span class="o">&amp;&amp;</span> useradd <span class="nt">-r</span> <span class="nt">-g</span> myuser myuser

<span class="c"># Set ownership and permissions</span>
<span class="k">RUN </span><span class="nb">chown</span> <span class="nt">-R</span> myuser:myuser /app

<span class="c"># Switch to the non-root user</span>
<span class="k">USER</span><span class="s"> myuser</span>

<span class="c"># Run the application</span>
<span class="k">CMD</span><span class="s"> ["python3", "app.py"]</span>
</code></pre></div></div> <p>In this improved example, a dedicated non-root user (myuser) is created using the useradd and groupadd commands. The ownership and permissions of the /app directory are changed to the non-root user using chown. Finally, the USER instruction switches to the non-root user before running the application.</p> <h3 id="34-create-a-non-root-user-in-the-dockerfile">3.4 Create a non-root user in the Dockerfile</h3> <p><a id="s3.4-create-a-non-root-user-in-the-dockerfile"></a></p> <p>Start your Dockerfile with a base image that already has a non-root user defined. This will ensure that your container starts with a non-root user by default</p> <p>If your base image doesn’t provide a non-root user, you should create one in your Dockerfile using the USER and RUN instructions. Specify a unique username and a non-privileged user ID (UID) for the user. This can be achieved with the following lines in your Dockerfile:</p> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">RUN </span>&lt;instructions that require to run with root privileges&gt;
<span class="k">RUN </span>addgroup <span class="nt">--system</span> nonroot <span class="o">&amp;&amp;</span> adduser <span class="nt">--system</span> <span class="nt">--ingroup</span> nonroot nonroot
<span class="k">USER</span><span class="s"> nonroot</span>
</code></pre></div></div> <p>Ensure that the non-root user has the necessary permissions to execute the required commands and access the required files and directories within the container. Use the RUN instruction with <code class="language-plaintext highlighter-rouge">chown</code> or <code class="language-plaintext highlighter-rouge">chmod</code> to adjust the ownership and permissions as needed.</p> <h3 id="35-avoid-running-containers-with-root-privileges">3.5 Avoid running containers with root privileges</h3> <p><a id="s3.5-avoid-running-containers-with-root-privileges"></a></p> <p>When starting the container, avoid running it as the root user. Instead, specify the <code class="language-plaintext highlighter-rouge">non-root</code> user as the user to run the container using the <code class="language-plaintext highlighter-rouge">--user</code> flag with the docker run command or the equivalent in your container orchestration platform.</p> <p>Why it’s important:</p> <ul> <li> <p>Running processes within a container as a non-root user minimizes the potential damage that can be caused by security vulnerabilities</p> </li> <li> <p>Following the principle of least privilege, a non-root user only has access to the resources and permissions necessary to perform its intended tasks. This reduces the risk of accidental or intentional misuse of privileged operations within the container.</p> </li> <li> <p>Running containers with a non-root user adds an additional layer of isolation between the containerized application and the host system. This isolation helps protect the host system from unintended changes or malicious activities within the container.</p> </li> <li> <p>Many organizations and regulatory frameworks require the use of non-root users for security and compliance purposes. Adhering to these best practices can help meet these requirements and ensure that your containerized applications pass security audits.</p> </li> </ul> <h2 id="4-other-references">4. Other references:</h2> <p><a id="s4-other-references"></a></p> <h3 id="41-expose">4.1 EXPOSE</h3> <p><a id="s4.1-expose"></a></p> <p>The <code class="language-plaintext highlighter-rouge">EXPOSE</code> instruction informs Docker that the container listens on the specified network ports at runtime. EXPOSE does not make the ports of the container accessible to the host.</p> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> nginx:latest</span>

<span class="c"># Expose port 80 for HTTP traffic</span>
<span class="k">EXPOSE</span><span class="s"> 80</span>
</code></pre></div></div> <p>In this example, the <code class="language-plaintext highlighter-rouge">EXPOSE</code> instruction is used to document that the containerized Nginx web server is expected to listen on port 80 for HTTP traffic. Users who want to connect to the running container can refer to the EXPOSE instruction to determine which ports should be accessed.</p> <p>To make the exposed ports accessible from the host machine, you need to publish them when running the container using the -p or -P option of the docker run command.</p> <p>For example, to publish port 80 of a container to port 8080 on the host machine:</p> <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">docker run -p 8080:80 myimage
</span></code></pre></div></div> <h3 id="42-entrypoint-vs-cmd-vs-run">4.2 ENTRYPOINT vs CMD vs RUN</h3> <p><a id="s4.2-entrypoint-vs-cmd-vs-run"></a></p> <ul> <li> <code class="language-plaintext highlighter-rouge">ENTRYPOINT</code>: The <code class="language-plaintext highlighter-rouge">ENTRYPOINT</code> instruction specifies the primary command to be executed when a container is run from an image. It sets the entrypoint for the container, which means it provides the default executable for the container. It is typically used to specify the main command or process that the container should run. You can use <code class="language-plaintext highlighter-rouge">ENTRYPOINT</code> in either the shell form (as a command string) or the exec form (as an array of strings).</li> </ul> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> ubuntu:20.04</span>

<span class="c"># Set the entrypoint command as an array</span>
<span class="k">ENTRYPOINT</span><span class="s"> ["echo", "Hello, World!"]</span>
</code></pre></div></div> <ul> <li> <code class="language-plaintext highlighter-rouge">CMD</code>: The <code class="language-plaintext highlighter-rouge">CMD</code> instruction provides default arguments for the entrypoint command defined by <code class="language-plaintext highlighter-rouge">ENTRYPOINT</code>. It sets the default parameters or arguments that will be passed to the entrypoint command when the container starts. <code class="language-plaintext highlighter-rouge">CMD</code> can also be specified in either the shell form (as a command string) or the exec form (as an array of strings). If the <code class="language-plaintext highlighter-rouge">CMD</code> instruction is present in the Dockerfile, it will be overridden by any command line arguments passed to the docker run command when starting the container.</li> </ul> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> ubuntu:20.04</span>

<span class="c"># Set the entrypoint command as an array</span>
<span class="k">ENTRYPOINT</span><span class="s"> ["echo"]</span>

<span class="c"># Set the default argument for the entrypoint command</span>
<span class="k">CMD</span><span class="s"> ["Hello, World!"]</span>
</code></pre></div></div> <ul> <li> <code class="language-plaintext highlighter-rouge">RUN</code>: The <code class="language-plaintext highlighter-rouge">RUN</code> instruction is used to execute commands during the build process of the Docker image. It runs commands within the image’s file system and creates a new layer with the changes made by the commands. <code class="language-plaintext highlighter-rouge">RUN</code> is typically used for installing dependencies, configuring the environment, or performing any actions needed to set up the image for runtime. Each <code class="language-plaintext highlighter-rouge">RUN</code> instruction creates a new layer in the Docker image, and the changes made by the command are preserved in that layer.</li> </ul> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> ubuntu:20.04</span>

<span class="c"># Run a command during the build process</span>
<span class="k">RUN </span>apt-get update <span class="o">&amp;&amp;</span> apt-get <span class="nb">install</span> <span class="nt">-y</span> curl
</code></pre></div></div> <p>More on <code class="language-plaintext highlighter-rouge">ENTRYPOINT</code>: In Docker, the <code class="language-plaintext highlighter-rouge">ENTRYPOINT</code> instruction is used in a Dockerfile to specify the primary command that should be run when a container is started from the image. It sets the executable that will be invoked by default when the container is run as an executable.</p> <p>Shell form:</p> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> ubuntu:20.04</span>
<span class="k">ENTRYPOINT</span><span class="s"> echo "Hello, World!"</span>
</code></pre></div></div> <p>Exec form:</p> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> ubuntu:20.04</span>
<span class="k">ENTRYPOINT</span><span class="s"> ["/bin/echo", "Hello, World!"]</span>
</code></pre></div></div> <p>In the shell form, the <code class="language-plaintext highlighter-rouge">ENTRYPOINT</code> instruction is specified as a command string. This command string is interpreted as a shell command, allowing for shell processing, variable substitution, and other shell features.</p> <p>In the exec form, the <code class="language-plaintext highlighter-rouge">ENTRYPOINT</code> instruction is specified as an array of strings. The first element of the array is the executable, and subsequent elements are passed as arguments to the executable.</p> <p>The ENTRYPOINT instruction provides a way to set a default command or executable for the container. Any additional parameters passed when running the container will be appended to the <code class="language-plaintext highlighter-rouge">ENTRYPOINT</code> command, allowing for flexibility and parameterization.</p> <p>In Python, here is how <code class="language-plaintext highlighter-rouge">ENTRYPOINT</code> can be used with <code class="language-plaintext highlighter-rouge">CMD</code>:</p> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> python:3.9-slim-buster</span>

<span class="k">WORKDIR</span><span class="s"> /app</span>

<span class="c"># Copy the Python application code</span>
<span class="k">COPY</span><span class="s"> app.py .</span>

<span class="c"># Set the entrypoint command</span>
<span class="k">ENTRYPOINT</span><span class="s"> ["python3"]</span>

<span class="c"># Set the default arguments for the entrypoint command</span>
<span class="k">CMD</span><span class="s"> ["app.py"]</span>
</code></pre></div></div> <p>In this example, the Dockerfile starts with a Python base image (<code class="language-plaintext highlighter-rouge">python:3.9-slim-buster</code>) and sets the working directory to <code class="language-plaintext highlighter-rouge">/app</code>. The Python application code file (<code class="language-plaintext highlighter-rouge">app.py</code>) is then copied into the image.</p> <p>The <code class="language-plaintext highlighter-rouge">ENTRYPOINT</code> instruction specifies the command that will be executed when the container starts. In this case, it sets the command to python3, which is the Python interpreter.</p> <p>The <code class="language-plaintext highlighter-rouge">CMD</code> instruction provides default arguments to the <code class="language-plaintext highlighter-rouge">ENTRYPOINT</code> command. In this case, the default argument is app.py, representing the Python script that will be executed.</p> <p>When you build and run the container, the Python application specified by app.py will be executed as the primary command. However, if you provide additional arguments when running the container, they will override the default arguments specified by <code class="language-plaintext highlighter-rouge">CMD</code>.</p> <h3 id="43-docker-image-vs-docker-containers">4.3 Docker Image vs Docker Containers:</h3> <p><a id="s4.3-docker-image-vs-docker-containers"></a></p> <p><img src="https://github.com/chrislevn/dockerfile-practices/assets/32094007/05fa9dc6-82b6-4fd9-be27-759d46632e25" alt="image"></p> <h4 id="431-docker-image">4.3.1 Docker Image:</h4> <p><a id="s4.3.1-docker-image"></a></p> <p>A Docker image is a lightweight, standalone, and executable package that contains everything needed to run a piece of software, including the code, runtime environment, libraries, dependencies, and system tools. It is created from a Dockerfile, which specifies the instructions for building the image. Images are immutable, meaning they are read-only and cannot be modified once created. You can think of an image as a blueprint or template for creating containers.</p> <h4 id="432-docker-container">4.3.2 Docker Container:</h4> <p><a id="s4.3.2-docker-container"></a></p> <p>A Docker container is a running instance of an image. It is a lightweight and isolated runtime environment that encapsulates an application and its dependencies. Containers are created from Docker images and can be started, stopped, paused, restarted, and deleted as needed. Each container runs in isolation, utilizing the host system’s resources efficiently while providing a consistent environment for the application to run. Containers are transient and can be recreated easily from the corresponding image.</p> <h4 id="433-docker-image-vs-containers">4.3.3 Docker Image vs Containers</h4> <p><a id="s4.3.3-docker-image-vs-containers"></a></p> <ul> <li>The key difference between a Docker image Vs a container is that a Docker image is a read-only immutable template that defines how a container will be realized. A Docker container is a runtime instance of a Docker image that gets created when the $ docker run command is implemented.</li> <li>Before the docker container can even exist docker templates/images are built using $ docker build CLI.</li> <li>Docker image templates can exist in isolation but containers can’t exist without images.</li> <li>So docker image is an integral part of containers that differs only because of their objectives which we have already covered.</li> <li>Docker images can’t be paused or started but a Docker container is a run time instance that can be started or paused.</li> </ul> <p>Reference: https://www.knowledgehut.com/blog/devops/docker-vs-container</p> <h3 id="44-workdir">4.4 WORKDIR</h3> <p><a id="s4.4-workdir"></a></p> <p>In a Dockerfile, the <code class="language-plaintext highlighter-rouge">WORKDIR</code> instruction is used to set the working directory for any subsequent instructions in the Dockerfile. It is similar to the cd command in Linux or Unix systems.</p> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">WORKDIR</span><span class="s"> /path/to/directory</span>
</code></pre></div></div> <p>Here, <code class="language-plaintext highlighter-rouge">/path/to/directory</code> is the absolute or relative path to the directory you want to set as the working directory. If the directory does not exist, Docker will create it.</p> <p>The <code class="language-plaintext highlighter-rouge">WORKDIR</code> instruction affects subsequent instructions like <code class="language-plaintext highlighter-rouge">RUN</code>, <code class="language-plaintext highlighter-rouge">CMD</code>, <code class="language-plaintext highlighter-rouge">COPY</code>, and <code class="language-plaintext highlighter-rouge">ADD</code>. Any relative paths specified in these instructions will be resolved relative to the working directory set by <code class="language-plaintext highlighter-rouge">WORKDIR</code>.</p> <p>It’s recommended to use absolute paths for better clarity and predictability in your Dockerfile.</p> <p>Here’s an example of how <code class="language-plaintext highlighter-rouge">WORKDIR</code> can be used in a Dockerfile:</p> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> ubuntu:latest</span>

<span class="k">WORKDIR</span><span class="s"> /app</span>

<span class="k">COPY</span><span class="s"> . /app</span>

<span class="k">RUN </span>apt-get update <span class="o">&amp;&amp;</span> <span class="se">\
</span>    apt-get <span class="nb">install</span> <span class="nt">-y</span> python3

<span class="k">CMD</span><span class="s"> ["python3", "app.py"]</span>
</code></pre></div></div> <p>For clarity and reliability, you should always use absolute paths for your WORKDIR. Also, you should use <code class="language-plaintext highlighter-rouge">WORKDIR</code> instead of proliferating instructions like <code class="language-plaintext highlighter-rouge">RUN cd … &amp;&amp; do-something</code>, which are hard to read, troubleshoot, and maintain.</p> <p>For more information about USER, see <a href="https://docs.docker.com/engine/reference/builder/#user" rel="external nofollow noopener" target="_blank">Dockerfile reference for the USER instruction</a>.</p> <h3 id="45-volume">4.5 VOLUME</h3> <p><a id="s4.5-volume"></a></p> <p>In a Dockerfile, the <code class="language-plaintext highlighter-rouge">VOLUME</code> instruction is used to create a mount point and designate a directory as a volume for persistent data storage or sharing between containers and the host system.</p> <p>The syntax for the <code class="language-plaintext highlighter-rouge">VOLUME</code> instruction is as follows:</p> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">VOLUME</span><span class="s"> ["/path/to/volume"]</span>
</code></pre></div></div> <p>Here, “/path/to/volume” specifies the absolute path to the directory that you want to designate as a volume.</p> <p>When you run a container using an image that includes a <code class="language-plaintext highlighter-rouge">VOLUME</code> instruction, Docker creates a mount point at the specified path and sets it as a volume. Any data written to that directory inside the container will be stored in the volume. The data in the volume persists even after the container is stopped or removed.</p> <p>Volumes are typically used for storing databases, logs, configuration files, or any other data that needs to persist beyond the lifecycle of a container. They provide a way to separate the storage of data from the container itself, making it easier to manage and migrate containers without losing important data.</p> <p>You can specify multiple VOLUME instructions in a Dockerfile to create multiple volumes.</p> <p>Here’s an example of how the VOLUME instruction can be used in a Dockerfile:</p> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> ubuntu:latest</span>

<span class="k">VOLUME</span><span class="s"> ["/app/data", "/app/logs"]</span>

<span class="k">WORKDIR</span><span class="s"> /app</span>

<span class="k">COPY</span><span class="s"> . /app</span>

<span class="k">CMD</span><span class="s"> ["python3", "app.py"]</span>
</code></pre></div></div> <p>In this example, the <code class="language-plaintext highlighter-rouge">VOLUME</code> instruction creates two volumes: <code class="language-plaintext highlighter-rouge">/app/data</code> and <code class="language-plaintext highlighter-rouge">/app/logs</code>. Any data written to these directories inside the container will be stored in the respective volumes. These volumes can then be accessed or managed using Docker commands or through container orchestration tools.</p> <p>The <code class="language-plaintext highlighter-rouge">VOLUME</code> instruction should be used to expose any database storage area, configuration storage, or files and folders created by your Docker container. You are strongly encouraged to use VOLUME for any combination of mutable or user-serviceable parts of your image.</p> <p>For more information about <code class="language-plaintext highlighter-rouge">VOLUME</code>, see <a href="https://docs.docker.com/engine/reference/builder/#volume" rel="external nofollow noopener" target="_blank">Dockerfile reference for the <code class="language-plaintext highlighter-rouge">VOLUME</code> instruction</a>.</p> <h3 id="46-user">4.6 USER</h3> <p><a id="s4.6-user"></a></p> <p>In a Dockerfile, the USER instruction is used to specify the user or UID (user identifier) that the container should run as when executing subsequent instructions.</p> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">USER</span><span class="s"> user[:group]</span>
</code></pre></div></div> <p>Here, user can be either the username or the UID of the user you want to set as the user for the container. Optionally, you can specify group to set the group for the user as well.</p> <p>The <code class="language-plaintext highlighter-rouge">USER</code> instruction is often used to run the container with a non-root user for security reasons. By default, Docker containers run as the root user (UID 0), which can pose security risks. Running the container as a non-root user helps to minimize the impact of potential security vulnerabilities.</p> <p>You can specify the user by either using the username or the UID. If you provide a username, Docker will try to resolve it to the corresponding UID and GID (group identifier) within the container. If you provide a UID directly, Docker will use that UID and assign it to the user.</p> <p>Here’s an example of how the <code class="language-plaintext highlighter-rouge">USER</code> instruction can be used in a Dockerfile:</p> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> ubuntu:latest</span>

<span class="k">RUN </span>groupadd <span class="nt">-r</span> mygroup <span class="o">&amp;&amp;</span> useradd <span class="nt">-r</span> <span class="nt">-g</span> mygroup myuser

<span class="k">WORKDIR</span><span class="s"> /app</span>

<span class="k">COPY</span><span class="s"> . /app</span>

<span class="k">USER</span><span class="s"> myuser</span>

<span class="k">CMD</span><span class="s"> ["python3", "app.py"]</span>
</code></pre></div></div> <p>In this example, the Dockerfile creates a new user named myuser and a group named mygroup. The <code class="language-plaintext highlighter-rouge">USER</code> instruction sets myuser as the user for subsequent instructions, starting from the <code class="language-plaintext highlighter-rouge">CMD</code> instruction. This ensures that the container runs with the specified user rather than the root user.</p> <p>If a service can run without privileges, use <code class="language-plaintext highlighter-rouge">USER</code> to change to a non-root user. Start by creating the user and group in the Dockerfile with something like the following example:</p> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">RUN </span>groupadd <span class="nt">-r</span> postgres <span class="o">&amp;&amp;</span> useradd <span class="nt">--no-log-init</span> <span class="nt">-r</span> <span class="nt">-g</span> postgres postgres
</code></pre></div></div> <h4 id="note">Note:</h4> <p>Consider an explicit UID/GID.</p> <p>Users and groups in an image are assigned a non-deterministic UID/GID in that the “next” UID/GID is assigned regardless of image rebuilds. So, if it’s critical, you should assign an explicit UID/GID.</p> <p>Avoid installing or using sudo as it has unpredictable <code class="language-plaintext highlighter-rouge">TTY</code> and signal-forwarding behavior that can cause problems. If you absolutely need functionality similar to <code class="language-plaintext highlighter-rouge">sudo</code>, such as initializing the daemon as <code class="language-plaintext highlighter-rouge">root</code> but running it as non-root, consider using “gosu”.</p> <p>Lastly, to reduce layers and complexity, avoid switching <code class="language-plaintext highlighter-rouge">USER</code> back and forth frequently.</p> <p>For more information about <code class="language-plaintext highlighter-rouge">USER</code>, see <a href="https://docs.docker.com/engine/reference/builder/#user" rel="external nofollow noopener" target="_blank">Dockerfile reference for the <code class="language-plaintext highlighter-rouge">USER</code> instruction</a>.</p> <p><a id="s3.6-user"></a></p> <h3 id="47-onbuild">4.7 ONBUILD</h3> <p><a id="s4.7-onbuild"></a></p> <p>The <code class="language-plaintext highlighter-rouge">ONBUILD</code> instruction is used to add triggers to an image that will be executed when the image is used as the base for another Docker image. It allows you to define actions that should be performed in child images without modifying the parent image.</p> <p>The syntax for the <code class="language-plaintext highlighter-rouge">ONBUILD</code> instruction is as follows:</p> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ONBUILD &lt;INSTRUCTION&gt;
</code></pre></div></div> <p>Here, <code class="language-plaintext highlighter-rouge">&lt;INSTRUCTION&gt;</code> can be any valid Dockerfile instruction like <code class="language-plaintext highlighter-rouge">RUN</code>, <code class="language-plaintext highlighter-rouge">COPY</code>, <code class="language-plaintext highlighter-rouge">CMD</code>, etc. It represents the action or instruction that should be executed in the child image.</p> <p>When an image with an <code class="language-plaintext highlighter-rouge">ONBUILD</code> instruction is used as the base image for another Docker image, the specified instruction is recorded and saved in the metadata of the parent image. Then, when the child image is built, Docker triggers and executes those recorded instructions as part of the child image build process.</p> <p>The <code class="language-plaintext highlighter-rouge">ONBUILD</code> instruction is typically used to automate certain tasks or actions that are common to many derived images. For example, you can use it to specify actions like copying files into the image, setting environment variables, or running commands.</p> <p>Here’s an example to illustrate the usage of <code class="language-plaintext highlighter-rouge">ONBUILD</code> in a Dockerfile:</p> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> ubuntu:latest</span>

<span class="k">ONBUILD</span><span class="w"> </span><span class="k">COPY</span><span class="s"> . /app</span>
<span class="k">ONBUILD RUN </span>make /app

<span class="k">CMD</span><span class="s"> ["./app"]</span>
</code></pre></div></div> <p>In this example, the parent image specifies two <code class="language-plaintext highlighter-rouge">ONBUILD</code> instructions. The first <code class="language-plaintext highlighter-rouge">ONBUILD</code> instruction records the <code class="language-plaintext highlighter-rouge">COPY . /app</code> instruction, which copies files from the context directory into the <code class="language-plaintext highlighter-rouge">/app</code> directory of the child image. The second <code class="language-plaintext highlighter-rouge">ONBUILD</code> instruction records the <code class="language-plaintext highlighter-rouge">RUN</code> make <code class="language-plaintext highlighter-rouge">/app</code> instruction, which builds the application in the child image.</p> <p>When the child image is built using this parent image, Docker will automatically execute the recorded <code class="language-plaintext highlighter-rouge">COPY . /app</code> and <code class="language-plaintext highlighter-rouge">RUN make /app</code> instructions in the child image build context. Finally, the <code class="language-plaintext highlighter-rouge">CMD</code> instruction will run the built application in the child image.</p> <p>An <code class="language-plaintext highlighter-rouge">ONBUILD</code> command executes after the current Dockerfile build completes. <code class="language-plaintext highlighter-rouge">ONBUILD</code> executes in any child image derived <code class="language-plaintext highlighter-rouge">FROM</code> the current image. Think of the <code class="language-plaintext highlighter-rouge">ONBUILD</code> command as an instruction that the parent Dockerfile gives to the child Dockerfile.</p> <p>A Docker build executes <code class="language-plaintext highlighter-rouge">ONBUILD</code> commands before any command in a child Dockerfile.</p> <p><code class="language-plaintext highlighter-rouge">ONBUILD</code> is useful for images that are going to be built <code class="language-plaintext highlighter-rouge">FROM</code> a given image. For example, you would use <code class="language-plaintext highlighter-rouge">ONBUILD</code> for a language stack image that builds arbitrary user software written in that language within the Dockerfile, as you can see in Ruby’s <code class="language-plaintext highlighter-rouge">ONBUILD</code> variants.</p> <p>Images built with <code class="language-plaintext highlighter-rouge">ONBUILD</code> should get a separate tag. For example, <code class="language-plaintext highlighter-rouge">ruby:1.9-onbuild</code> or <code class="language-plaintext highlighter-rouge">ruby:2.0-onbuild</code>.</p> <p>Be careful when putting <code class="language-plaintext highlighter-rouge">ADD</code> or <code class="language-plaintext highlighter-rouge">COPY</code> in <code class="language-plaintext highlighter-rouge">ONBUILD</code>. The onbuild image fails catastrophically if the new build’s context is missing the resource being added. Adding a separate tag, as recommended above, helps mitigate this by allowing the Dockerfile author to make a choice.</p> <p>For more information about ONBUILD, see <a href="https://docs.docker.com/engine/reference/builder/#onbuild" rel="external nofollow noopener" target="_blank">Dockerfile reference for the <code class="language-plaintext highlighter-rouge">ONBUILD</code> instruction</a>.</p> <p>Reference: <a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" rel="external nofollow noopener" target="_blank">https://docs.docker.com/develop/develop-images/dockerfile_best-practices/</a></p> <h2 id="5-good-demo">5. Good demo</h2> <p><a id="s5-good-demo"></a></p> <div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Use a suitable base image</span>
<span class="k">FROM</span><span class="s"> python:3.9-slim-buster</span>

<span class="c"># Set the working directory</span>
<span class="k">WORKDIR</span><span class="s"> /app</span>

<span class="c"># Copy only necessary files</span>
<span class="k">COPY</span><span class="s"> requirements.txt .</span>
<span class="k">COPY</span><span class="s"> app.py .</span>

<span class="c"># Install dependencies</span>
<span class="k">RUN </span>pip <span class="nb">install</span> <span class="nt">--no-cache-dir</span> <span class="nt">-r</span> requirements.txt

<span class="c"># Set the container user</span>
<span class="k">RUN </span>groupadd <span class="nt">-r</span> myuser <span class="o">&amp;&amp;</span> useradd <span class="nt">-r</span> <span class="nt">-g</span> myuser myuser
<span class="k">USER</span><span class="s"> myuser</span>

<span class="c"># Expose the necessary port</span>
<span class="k">EXPOSE</span><span class="s"> 8000</span>

<span class="c"># Set environment variables</span>
<span class="k">ENV</span><span class="s"> DB_HOST=localhost</span>
<span class="k">ENV</span><span class="s"> DB_PORT=3306</span>
<span class="k">ENV</span><span class="s"> DB_USER=defaultuser</span>
<span class="k">ENV</span><span class="s"> DB_PASSWORD=defaultpassword</span>

<span class="c"># Set the entrypoint command</span>
<span class="k">CMD</span><span class="s"> ["python3", "app.py"]</span>
</code></pre></div></div> <p>In this example, we follow several best practices:</p> <ul> <li>We use an appropriate base image (<code class="language-plaintext highlighter-rouge">python:3.9-slim-buster</code>) that provides a minimal Python environment.</li> <li>We set the working directory to <code class="language-plaintext highlighter-rouge">/app</code> to execute commands and copy files within that directory.</li> <li>Only necessary files (<code class="language-plaintext highlighter-rouge">requirements.txt</code> and <code class="language-plaintext highlighter-rouge">app.py</code>) are copied into the image, reducing unnecessary content. -Dependencies are installed using pip with the <code class="language-plaintext highlighter-rouge">--no-cache-dir</code> flag to avoid caching unnecessary artifacts. -A non-root user (<code class="language-plaintext highlighter-rouge">myuser</code>) is created and used to run the container, enhancing security. -The necessary port (<code class="language-plaintext highlighter-rouge">8000</code>) is exposed to allow access to the application. -Environment variables are set for configuring the database connection. -The <code class="language-plaintext highlighter-rouge">CMD</code> instruction specifies the command to run when the container starts.</li> </ul> <p>More demos on <a href="https://github.com/chrislevn/dockerfile-practices/tree/main/demo" rel="external nofollow noopener" target="_blank">https://github.com/chrislevn/dockerfile-practices/tree/main/demo</a></p> <h2 id="6-basic-steps-to-running-docker-file-with-docker-cli">6. Basic steps to running Docker file with docker cli:</h2> <p><a id="s6-basic-steps-to-running-docker-file-with-docker-cli"></a></p> <ul> <li>Make sure you have Docker installed and running on your system. You can check this by running the docker version command in your terminal or command prompt. If you have Docker Destop, make sure it is running.</li> <li>Create a Dockerfile in your project directory. The Dockerfile contains instructions for building your Docker image.</li> <li>Open a terminal or command prompt and navigate to the directory where your Dockerfile is located.</li> <li>Build the Docker image using the <code class="language-plaintext highlighter-rouge">docker build</code> command. Provide a tag for your image using the <code class="language-plaintext highlighter-rouge">-t</code> option. For example:</li> </ul> <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">docker build -t myapp:1.0 .
</span></code></pre></div></div> <p>This command builds an image with the tag <code class="language-plaintext highlighter-rouge">myapp:1.0</code> using the Dockerfile in the current directory (<code class="language-plaintext highlighter-rouge">.</code>).</p> <p>Once the image is built, you can run a container based on that image using the docker run command. Specify the image name or tag with the -it option for an interactive session. For example:</p> <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">docker run -it myapp:1.0
</span></code></pre></div></div> <p>This command starts a container based on the myapp:1.0 image. <code class="language-plaintext highlighter-rouge">-it</code> is short for <code class="language-plaintext highlighter-rouge">--interactive</code> + <code class="language-plaintext highlighter-rouge">--tty</code>. When you docker run with this command it takes you straight inside the container.</p> <p>Note: If your application requires ports to be exposed, you can use the -p option to map container ports to host ports. For example, to expose port <code class="language-plaintext highlighter-rouge">8000</code>:</p> <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">docker run -it -p 8000:8000 myapp:1.0
</span></code></pre></div></div> <h3 id="61-running-docker-with-docker-compose">6.1 Running Docker with Docker compose</h3> <p><a id="s6.1-run-docker-with-docker-compose"></a></p> <h4 id="611-docker-compose">6.1.1 Docker compose</h4> <p><a id="s6.1.1-docker-compose"></a></p> <p>Docker Compose is a tool that allows you to define and manage multi-container Docker applications. It provides a way to describe the configuration of multiple services, networks, and volumes using a YAML file format. With Docker Compose, you can define a set of containers that make up your application, specify their configurations, and manage their lifecycle as a single unit.</p> <h4 id="612-docker-compose-vs-docker-run">6.1.2 Docker compose vs Docker run</h4> <p><a id="s6.1.2-docker-compose-vs-docker-run"></a></p> <ol> <li> <strong>Docker Compose:</strong> Docker Compose is used for managing multi-container applications. It allows you to define and orchestrate multiple containers, their configurations, networks, and volumes using a declarative YAML file called a Compose file. With Docker Compose, you can define the desired state of your application and manage it as a single unit. Compose simplifies the process of running complex applications with multiple interconnected services, making it easier to replicate and share application environments across different environments.</li> </ol> <p>To run a Dockerfile with Docker compose, we use</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker compose up
</code></pre></div></div> <ol> <li> <code class="language-plaintext highlighter-rouge">docker run</code> command: The <code class="language-plaintext highlighter-rouge">docker run</code> command is used to run a single container. It allows you to start a container from a specific Docker image with specific configurations. You can specify various options such as environment variables, exposed ports, volume mounts, and networking settings when running a container with <code class="language-plaintext highlighter-rouge">docker run</code>. The <code class="language-plaintext highlighter-rouge">docker run</code> command is typically used for running individual containers in isolation rather than managing complex multi-container applications.</li> </ol> <p>To run with docker run, we use</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run &lt;IMAGE_NAME&gt;:&lt;TAG&gt;
</code></pre></div></div> <h4 id="613-docker-compose-usage">6.1.3 Docker compose usage</h4> <p><a id="s6.1.3-docker-compose-usage"></a></p> <ul> <li>Add <code class="language-plaintext highlighter-rouge">docker-compose.yml</code> in the same directory of your <code class="language-plaintext highlighter-rouge">Dockerfile</code> </li> </ul> <p>Sample <code class="language-plaintext highlighter-rouge">docker-compose.yml</code> file:</p> <pre><code class="language-YAML">version: "1"                        #   Specifies the version of Docker Compose syntax being used.
services:                           #   Defines the services within the Docker Compose file.
  deployment:                       #   Represents the first service name
    image: &lt;IMAGE_NAME&gt;:$VERSION  #   Specifies the Docker image to be used for the "deployment" service. 
                                    #   It uses a variable $VERSION to dynamically specify the image version.
    build:                          #   Configures the build settings for the container.            
      dockerfile: Dockerfile        #   It specifies the Dockerfile to be used for building the container. 
                                    #   It assumes there is a file named Dockerfile in the same directory.
    ports:                          #   Maps ports between the container and the host machine.
      - "5001:5001"                 #   Binds port 5001 of the container to port 5001 of the host machine.
    volumes:                        #   Mounts directories or files from the host machine to the container.
      - .:/app    #   Mounts the current directory (denoted by .) to the /app directory inside the container.
    environment:                    #   Mounts directories or files from the host machine to the container. 
      PORT: 5001                    #   Sets the environment variable PORT to the value 5001.
      AUTHOR: "Christopher Le"      #   Sets the environment variable AUTHOR to the value "Christopher Le".

</code></pre> <ul> <li>Build the image first by running <div class="language-bash highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>docker run &lt;IMAGE_NAME&gt;:<span class="nv">$VERSION</span>
</code></pre></div> </div> </li> <li>Run docker compose by</li> </ul> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker compose up
</code></pre></div></div> <p>To disable docker compose, run</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker compose down
</code></pre></div></div> <h3 id="62-running-docker-image-with-kubernetes">6.2 Running Docker image with Kubernetes</h3> <p><a id="s6.2-run-docker-with-kubernetes"></a></p> <h4 id="621-what-is-kubernetes">6.2.1 What is Kubernetes</h4> <p><a id="s6.2.1-what-is-kubernetes"></a></p> <p>Kubernetes is an open-source container orchestration platform developed by Google. It automates the deployment, scaling, and management of containerized applications. With Kubernetes, you can easily manage and coordinate multiple containers that run across a cluster of servers.</p> <h4 id="622-running-public-docker-image-with-kubernetes">6.2.2 Running public Docker image with Kubernetes</h4> <p><a id="s6.2.2-run-public-docker-image-with-kubernetes"></a></p> <ol> <li> <strong>Build the Docker Image:</strong> Build the Docker image using the Dockerfile. Run the following command in the directory containing the Dockerfile:</li> </ol> <div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">docker</span> <span class="nv">build</span> <span class="o">-</span><span class="nv">t</span> <span class="k">my</span><span class="o">-</span><span class="nv">python</span><span class="o">-</span><span class="nv">app</span> <span class="o">.</span>
</code></pre></div></div> <ol> <li> <strong>Push the Docker Image:</strong> Push the built image to a container registry of your choice, such as Docker Hub or a private registry. This step is necessary if you want to deploy the image from the registry using Kubernetes. Here’s an example command to push the image to Docker Hub:</li> </ol> <div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">docker</span> <span class="nb">push</span> <span class="nv">your</span><span class="o">-</span><span class="nv">docker</span><span class="o">-</span><span class="nv">username</span><span class="o">/</span><span class="k">my</span><span class="o">-</span><span class="nv">python</span><span class="o">-</span><span class="nv">app</span>
</code></pre></div></div> <ol> <li><strong>Create Kubernetes Configurations:</strong></li> </ol> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Deployment</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">my-app-deployment</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">replicas</span><span class="pi">:</span> <span class="m">3</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">matchLabels</span><span class="pi">:</span>
      <span class="na">app</span><span class="pi">:</span> <span class="s">my-app</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">metadata</span><span class="pi">:</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="na">app</span><span class="pi">:</span> <span class="s">my-app</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">containers</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">my-app-container</span>
          <span class="na">image</span><span class="pi">:</span> <span class="s">your-docker-username/my-python-app</span>
          <span class="na">ports</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="m">5001</span>
          <span class="na">env</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">PORT</span>
              <span class="na">value</span><span class="pi">:</span> <span class="s2">"</span><span class="s">5001"</span>
            <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">AUTHOR</span>
              <span class="na">value</span><span class="pi">:</span> <span class="s2">"</span><span class="s">Christopher</span><span class="nv"> </span><span class="s">Le"</span>
</code></pre></div></div> <ol> <li> <strong>Deploy the Kubernetes Objects:</strong> Apply the Kubernetes configuration by running the following command:</li> </ol> <div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">kubectl</span> <span class="nv">apply</span> <span class="o">-</span><span class="nv">f</span> <span class="k">my</span><span class="o">-</span><span class="nv">app</span><span class="o">-</span><span class="nv">deployment</span><span class="o">.</span><span class="nv">yaml</span>
</code></pre></div></div> <ol> <li> <strong>Accessing the Application:</strong> By default, the application is accessible within the Kubernetes cluster. To expose it externally, you can create a Kubernetes service. Create a YAML file (e.g., <code class="language-plaintext highlighter-rouge">my-app-service.yaml</code>) with the following contents:</li> </ol> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Service</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">my-app-service</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">app</span><span class="pi">:</span> <span class="s">my-app</span>
  <span class="na">ports</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">protocol</span><span class="pi">:</span> <span class="s">TCP</span>
      <span class="na">port</span><span class="pi">:</span> <span class="m">80</span>
      <span class="na">targetPort</span><span class="pi">:</span> <span class="m">5001</span>
  <span class="na">type</span><span class="pi">:</span> <span class="s">LoadBalancer</span>
</code></pre></div></div> <p>This configuration creates a LoadBalancer service that exposes the application on port 80. Apply the service by running the following command:</p> <div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">kubectl</span> <span class="nv">apply</span> <span class="o">-</span><span class="nv">f</span> <span class="k">my</span><span class="o">-</span><span class="nv">app</span><span class="o">-</span><span class="nv">service</span><span class="o">.</span><span class="nv">yaml</span>
</code></pre></div></div> <p>Once the service is created, you can access your application using the external IP address assigned to the service. Open a web browser and visit <code class="language-plaintext highlighter-rouge">http://&lt;external-ip&gt;:80</code> to interact with your application.</p> <h4 id="623-running-private-docker-image-with-kubernetes">6.2.3 Running private Docker image with Kubernetes</h4> <p><a id="s6.2.3-run-private-docker-image-with-kubernetes"></a></p> <ol> <li> <strong>Create a Secret:</strong> Kubernetes provides a mechanism called Secrets to store sensitive information securely, such as credentials for accessing private container registries. Create a Secret to store the authentication details required to pull the private Docker image. Run the following command, replacing the placeholders with your registry credentials:</li> </ol> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl create secret docker-registry &lt;secret-name&gt; <span class="nt">--docker-server</span><span class="o">=</span>&lt;registry-server&gt; <span class="nt">--docker-username</span><span class="o">=</span>&lt;username&gt; <span class="nt">--docker-password</span><span class="o">=</span>&lt;password&gt; <span class="nt">--docker-email</span><span class="o">=</span>&lt;email&gt;
</code></pre></div></div> <ul> <li> <code class="language-plaintext highlighter-rouge">&lt;secret-name&gt;</code> is the name you choose for the Secret.</li> <li> <code class="language-plaintext highlighter-rouge">&lt;registry-server&gt;</code> is the URL of your private container registry.</li> <li> <code class="language-plaintext highlighter-rouge">&lt;username&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;password&gt;</code>, and <code class="language-plaintext highlighter-rouge">&lt;email&gt;</code> are the credentials required to access the registry.</li> </ul> <ol> <li> <strong>Update the Kubernetes Deployment:</strong> Modify your Kubernetes Deployment configuration to use the created Secret for authentication. Add the following section to your Deployment configuration:</li> </ol> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">spec</span><span class="pi">:</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">imagePullSecrets</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">&lt;secret-name&gt;</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">&lt;secret-name&gt;</code> should match the name you provided when creating the Secret in the previous step.</p> <ol> <li> <strong>Apply the Changes:</strong> Apply the updated Deployment configuration using the kubectl apply command:</li> </ol> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl apply <span class="nt">-f</span> &lt;deployment-file&gt;.yaml
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">&lt;deployment-file&gt;.yaml</code> is the path to your Deployment configuration file.</p> <ol> <li> <strong>Kubernetes Pulls Private Image:</strong> With the Secret configured in the Deployment, Kubernetes will use the provided credentials to authenticate with your private container registry and pull the image when deploying the application.</li> </ol> <p>Ensure that the Kubernetes cluster where you are deploying your application has network access to the private container registry. If the registry is within a private network, you may need to configure additional networking or authentication mechanisms to establish the connection.</p> <h4 id="624-running-docker-image-with-minikube">6.2.4 Running Docker image with Minikube</h4> <p><a id="s6.2.4-run-docker-image-with-minikube"></a></p> <p><strong>Minikube</strong> is a lightweight Kubernetes implementation that creates a VM on your local machine and deploys a simple cluster containing only one node. Minikube is available for Linux, macOS, and Windows systems.</p> <ol> <li> <strong>Start Minikube:</strong> Start Minikube on your local machine by running the following command:</li> </ol> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>minikube start
</code></pre></div></div> <ol> <li> <strong>Build the Docker Image:</strong> Build the Docker image for your application using the Dockerfile. Navigate to the directory containing the Dockerfile and run the following command:</li> </ol> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker build <span class="nt">-t</span> my-app-image <span class="nb">.</span>
</code></pre></div></div> <ol> <li> <strong>Load Docker Image into Minikube:</strong> Load the Docker image into the Minikube environment by running the following command:</li> </ol> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">eval</span> <span class="si">$(</span>minikube docker-env<span class="si">)</span>
docker image load <span class="nt">-i</span> my-app-image.tar
</code></pre></div></div> <ol> <li> <strong>Create Kubernetes Deployment:</strong> Create a Kubernetes Deployment configuration file (e.g., <code class="language-plaintext highlighter-rouge">my-app-deployment.yaml</code>) to define the deployment of your application. Here’s an example configuration for a simple deployment:</li> </ol> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Deployment</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">my-app-deployment</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">replicas</span><span class="pi">:</span> <span class="m">1</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">matchLabels</span><span class="pi">:</span>
      <span class="na">app</span><span class="pi">:</span> <span class="s">my-app</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">metadata</span><span class="pi">:</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="na">app</span><span class="pi">:</span> <span class="s">my-app</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">containers</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">my-app-container</span>
          <span class="na">image</span><span class="pi">:</span> <span class="s">my-app-image</span>
          <span class="na">ports</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="m">80</span>
</code></pre></div></div> <ol> <li> <strong>Apply the Deployment:</strong> Apply the Deployment configuration to create the deployment in Minikube by running the following command:</li> </ol> <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">kubectl apply -f my-app-deployment.yaml
</span></code></pre></div></div> <ol> <li> <strong>Expose the Deployment:</strong> To access your application, you need to expose it outside the cluster. In Minikube, you can create a NodePort service to expose the deployment. Create a service configuration file (e.g., <code class="language-plaintext highlighter-rouge">my-app-service.yaml</code>) with the following contents:</li> </ol> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Service</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">my-app-service</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">app</span><span class="pi">:</span> <span class="s">my-app</span>
  <span class="na">type</span><span class="pi">:</span> <span class="s">NodePort</span>
  <span class="na">ports</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">port</span><span class="pi">:</span> <span class="m">80</span>
      <span class="na">targetPort</span><span class="pi">:</span> <span class="m">80</span>
      <span class="na">nodePort</span><span class="pi">:</span> <span class="m">30000</span>
</code></pre></div></div> <p>This configuration creates a NodePort service that exposes the application on <code class="language-plaintext highlighter-rouge">port 30000</code>. Apply the service by running the following command:</p> <div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">kubectl</span> <span class="nv">apply</span> <span class="o">-</span><span class="nv">f</span> <span class="k">my</span><span class="o">-</span><span class="nv">app</span><span class="o">-</span><span class="nv">service</span><span class="o">.</span><span class="nv">yaml</span>
</code></pre></div></div> <ol> <li> <strong>Access the Application:</strong> To access your application, you can use the Minikube IP and the NodePort assigned to the service. Run the following command to get the Minikube IP:</li> </ol> <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">minikube ip
</span></code></pre></div></div> <p>Remember to clean up the resources when you’re done by running <code class="language-plaintext highlighter-rouge">kubectl delete deployment my-app-deployment</code> and <code class="language-plaintext highlighter-rouge">kubectl delete service my-app-service</code>. Additionally, you can stop Minikube by running <code class="language-plaintext highlighter-rouge">minikube stop</code>.</p> <h3 id="63-add-load-balancer-with-nginx">6.3 Add load balancer with Nginx</h3> <p><a id="s6.3-add-load-balancer-with-nginx"></a></p> <h4 id="631-what-is-load-balancer">6.3.1 What is load balancer</h4> <p><a id="s6.3.1-what-is-load-balancer"></a></p> <p>A load balancer is a networking device or software component that evenly distributes incoming network traffic across multiple servers or resources. It acts as a central point of contact for client requests and forwards those requests to the appropriate backend servers based on predefined rules or algorithms.</p> <h4 id="632-ngnix">6.3.2 Ngnix</h4> <p><a id="s6.3.2-ngnix"></a></p> <p><strong>Nginx</strong> (pronounced “engine-x”) is a popular open-source web server and reverse proxy server. It is known for its high performance, scalability, and ability to efficiently handle concurrent connections. Nginx is designed to handle a large number of client requests while consuming fewer resources compared to traditional web servers.</p> <p><strong>Nginx</strong> is often used as a load balancer alongside its web server capabilities. It can be configured as a reverse proxy and load balancer to distribute incoming traffic across multiple backend servers. This makes Nginx a versatile tool for managing and scaling web applications.</p> <h4 id="633-add-load-balancer-to-docker-compose">6.3.3 Add load balancer to Docker compose</h4> <p><a id="s6.3.3-add-load-balancer-to-docker-compose"></a></p> <p>To add a load balancer to a Docker Compose configuration, you can use a reverse proxy server, such as Nginx or HAProxy, to distribute incoming traffic across multiple containers running your application. Here’s an example of how you can add Nginx as a load balancer in a Docker Compose file:</p> <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3'</span>

<span class="na">services</span><span class="pi">:</span>
  <span class="na">nginx</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">nginx:latest</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">80:80</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./nginx.conf:/etc/nginx/nginx.conf</span>
    <span class="na">depends_on</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">app1</span>
      <span class="pi">-</span> <span class="s">app2</span>

  <span class="na">app1</span><span class="pi">:</span>
    <span class="na">build</span><span class="pi">:</span>
      <span class="na">context</span><span class="pi">:</span> <span class="s">./app1</span>
    <span class="c1"># Other configurations for your app1 container</span>

  <span class="na">app2</span><span class="pi">:</span>
    <span class="na">build</span><span class="pi">:</span>
      <span class="na">context</span><span class="pi">:</span> <span class="s">./app2</span>
    <span class="c1"># Other configurations for your app2 container</span>
</code></pre></div></div> <p>In the above example, we have three services defined: <code class="language-plaintext highlighter-rouge">nginx</code>, <code class="language-plaintext highlighter-rouge">app1</code>, and <code class="language-plaintext highlighter-rouge">app2</code>. The nginx service uses the official Nginx image and maps <code class="language-plaintext highlighter-rouge">port 80</code> of the host to port 80 of the Nginx container. The volumes section mounts a custom <code class="language-plaintext highlighter-rouge">nginx.conf</code> file, which we’ll create next.</p> <p>Create an <code class="language-plaintext highlighter-rouge">nginx.conf</code> file in the same directory as the Docker Compose file with the following content:</p> <div class="language-conf highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">events</span> {}

<span class="n">http</span> {
  <span class="n">upstream</span> <span class="n">app_servers</span> {
    <span class="n">server</span> <span class="n">app1</span>:<span class="m">5000</span>;
    <span class="n">server</span> <span class="n">app2</span>:<span class="m">5000</span>;
  }

  <span class="n">server</span> {
    <span class="n">listen</span> <span class="m">80</span>;
    <span class="n">server_name</span> <span class="n">localhost</span>;

    <span class="n">location</span> / {
      <span class="n">proxy_pass</span> <span class="n">http</span>://<span class="n">app_servers</span>;
      <span class="n">proxy_set_header</span> <span class="n">Host</span> $<span class="n">host</span>;
      <span class="n">proxy_set_header</span> <span class="n">X</span>-<span class="n">Real</span>-<span class="n">IP</span> $<span class="n">remote_addr</span>;
    }
  }
}
</code></pre></div></div> <p>In the <code class="language-plaintext highlighter-rouge">nginx.conf</code>, we define an upstream block called app_servers, which lists the hostnames and ports of the backend application containers (<code class="language-plaintext highlighter-rouge">app1</code> and <code class="language-plaintext highlighter-rouge">app2</code>). The server block sets up the Nginx configuration to listen on <code class="language-plaintext highlighter-rouge">port 80</code> and forward incoming requests to the <code class="language-plaintext highlighter-rouge">app_servers</code> upstream.</p> <p>To start the Docker Compose stack, navigate to the directory containing the Docker Compose file and run the following command:</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker compose up
</code></pre></div></div> <p>This will start the Nginx container and the two application containers (<code class="language-plaintext highlighter-rouge">app1</code> and <code class="language-plaintext highlighter-rouge">app2</code>). Incoming traffic will be load balanced by Nginx and forwarded to the backend application containers based on the configuration in <code class="language-plaintext highlighter-rouge">nginx.conf</code>.</p> <p>Make sure to adjust the build configurations for <code class="language-plaintext highlighter-rouge">app1</code> and <code class="language-plaintext highlighter-rouge">app2</code> according to your application’s needs. Also, update the port numbers and other settings as required for your specific use case.</p> <p>Note: This configuration assumes that your backend application containers (<code class="language-plaintext highlighter-rouge">app1</code> and <code class="language-plaintext highlighter-rouge">app2</code>) are configured to listen on <code class="language-plaintext highlighter-rouge">port 5000</code>. Adjust the upstream server addresses accordingly if your containers use different ports.</p> <hr> <h2 id="7-contributing">7. Contributing</h2> <p><a id="s7-contributing"></a></p> <h3 id="71-contributing-guide"><a href="https://github.com/chrislevn/dockerfile-practices/blob/main/CONTRIBUTING.md" rel="external nofollow noopener" target="_blank">7.1 Contributing guide</a></h3> <p><a id="s7.1-contributing-guide"></a></p> <h3 id="72-acknowledgement">7.2 Acknowledgement</h3> <p><a id="s7.2-acknowledgement"></a></p> <ul> <li> <a href="https://github.com/ducthinh993" rel="external nofollow noopener" target="_blank">Thinh Nguyen</a> - 3.4, 3.5</li> </ul> <h2 id="8-references">8. References:</h2> <p><a id="s8-references"></a></p> <ul> <li><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" rel="external nofollow noopener" target="_blank">https://docs.docker.com/develop/develop-images/dockerfile_best-practices/</a></li> <li><a href="https://medium.com/@adari.girishkumar/dockerfile-and-best-practices-for-writing-dockerfile-diving-into-docker-part-5-5154d81edca4" rel="external nofollow noopener" target="_blank">https://medium.com/@adari.girishkumar/dockerfile-and-best-practices-for-writing-dockerfile-diving-into-docker-part-5-5154d81edca4</a></li> <li><a href="https://google.github.io/styleguide/pyguide.html" rel="external nofollow noopener" target="_blank">https://google.github.io/styleguide/pyguide.html</a></li> <li><a href="https://github.com/dnaprawa/dockerfile-best-practices" rel="external nofollow noopener" target="_blank">https://github.com/dnaprawa/dockerfile-best-practices</a></li> <li><a href="https://we-are.bookmyshow.com/understanding-expose-in-dockerfile-266938b6a33d" rel="external nofollow noopener" target="_blank">https://we-are.bookmyshow.com/understanding-expose-in-dockerfile-266938b6a33d</a></li> <li><a href="https://towardsdatascience.com/goodbye-pip-freeze-welcome-pipreqs-258d2e7a5a62" rel="external nofollow noopener" target="_blank">https://towardsdatascience.com/goodbye-pip-freeze-welcome-pipreqs-258d2e7a5a62</a></li> <li><a href="https://www.knowledgehut.com/blog/devops/docker-vs-container" rel="external nofollow noopener" target="_blank">https://www.knowledgehut.com/blog/devops/docker-vs-container</a></li> <li><a href="https://refine.dev/blog/docker-build-args-and-env-vars/#how-to-pass-arg-variables" rel="external nofollow noopener" target="_blank">https://refine.dev/blog/docker-build-args-and-env-vars/#how-to-pass-arg-variables</a></li> </ul> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/inside-browser/">What happens when you type a URL into your browser? — The big picture (with Cloud)</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/clickhouse/">Visualize your data from cloud with DoubleCloud and ClickHouse DB</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/backend-languages/">Top backend languages and when to use them</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2020/basic-js-algorithms/">Basic Algorithms in JavaScript (part 1)</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2019/will-ai-replace-human/">Will AI replace human labor?</a> </li> <div id="giscus_thread" style="max-width: 800px; margin: 0 auto;"> <script>let giscusTheme=localStorage.getItem("theme"),giscusAttributes={src:"https://giscus.app/client.js","data-repo":"chrislevn/chrislevn.github.io","data-repo-id":"","data-category":"Comments","data-category-id":"","data-mapping":"title","data-strict":"1","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":giscusTheme,"data-lang":"en",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([t,e])=>giscusScript.setAttribute(t,e)),document.getElementById("giscus_thread").appendChild(giscusScript);</script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2023 Christopher Loc Le. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a>. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?7b30caa5023af4af8408a472dc4e1ebb"></script> <script defer src="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?c9d9dd48933de3831b3ee5ec9c209cac" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-1L7EPL0Z80"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-1L7EPL0Z80");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>